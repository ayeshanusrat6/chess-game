<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chess — Online & Offline (Stakes & Coins)</title>
  <style>
    :root{ --bg:#0f1724; --card:#0b1220; --accent:#06b6d4; --muted:#9aa6b2; --win:#10b981; --lose:#ef4444 }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Arial}
    body{margin:0;background:linear-gradient(180deg,#071026 0%, #071422 100%);color:#e6eef6;min-height:100vh;padding:18px}
    .app{display:grid;grid-template-columns:360px 1fr;gap:18px;align-items:start}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.7);}
    header h1{margin:0;font-size:20px}
    .left .section{margin-bottom:12px}
    .account-row{display:flex;justify-content:space-between;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    .coins{display:flex;gap:10px;align-items:center}
    .coin-badge{background:linear-gradient(90deg,#ffd166,#f97316);color:#051025;padding:6px 10px;border-radius:999px;font-weight:700}
    .btn{background:var(--accent);color:#022; padding:8px 10px;border-radius:8px;font-weight:600;border:none;cursor:pointer}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .stakes{display:flex;gap:8px;margin-top:10px}
    .stake{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer}
    .stake.active{background:rgba(6,182,212,0.12);border-color:rgba(6,182,212,0.3)}
    .modes{display:flex;gap:8px;margin-top:8px}
    .status{margin-top:8px;font-size:13px}
    .match-log{height:140px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:10px;font-size:13px}

    /* board */
    .board-wrap{display:flex;gap:18px;align-items:flex-start}
    .board{width:480px;height:480px;background:#dcdcdc;border-radius:8px;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);overflow:hidden}
    .square{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:28px;cursor:pointer;user-select:none}
    .sq-dark{background:#6b4f36}
    .sq-light{background:#f3ecd6}
    .highlight{outline:4px solid rgba(6,182,212,0.24);}
    .piece{pointer-events:none}

    /* right side */
    .controls{display:flex;flex-direction:column;gap:12px}
    .moves{height:220px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
    .small-muted{color:var(--muted);font-size:13px}
    footer{margin-top:12px;color:var(--muted);font-size:13px}

    @media (max-width:940px){.app{grid-template-columns:1fr;}.board{width:100%;height:360px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card left">
      <header>
        <h1>Online — Choose stake & mode</h1>
        <div class="small">Play Random / Play with Friend / Local & Offline</div>
      </header>

      <div class="section">
        <div class="account-row">
          <div>
            <div class="small">Account</div>
            <div id="playerName">Player-a423</div>
            <div class="small-muted" id="playerId">Player ID: generating...</div>
          </div>
          <div class="coins">
            <div class="coin-badge" id="coins">0</div>
          </div>
        </div>

        <div style="margin-top:10px;display:flex;gap:8px;">
          <button class="btn" id="saveBtn">Save</button>
          <button class="btn ghost" id="importBtn">Import/Restore</button>
        </div>
      </div>

      <div class="section">
        <div class="small">Select Stake</div>
        <div class="stakes" id="stakes">
          <div class="stake" data-value="5">5</div>
          <div class="stake" data-value="10">10</div>
          <div class="stake" data-value="20">20</div>
        </div>

        <div class="small" style="margin-top:8px">Mode</div>
        <div class="modes">
          <button class="btn ghost" id="modeFriend">Play with Friend</button>
          <button class="btn" id="modeRandom">Play Random</button>
          <button class="btn" id="modeOffline">Offline (vs Computer)</button>
        </div>

        <div class="status small" id="status">Status: Idle</div>
        <div class="match-log" id="matchLog">[-- match log --]</div>
      </div>

      <div class="section">
        <div class="small">Help & Notes</div>
        <div class="small-muted" style="margin-top:6px">
          Open this page in another tab to simulate online players (local multi-tab). For real cross-device matches you need a server. Chess rules are enforced using chess.js. Coins are stored in localStorage and used for stakes/computer wins.
        </div>
      </div>

      <div class="section">
        <div class="small">Daily Bonus</div>
        <div style="display:flex;gap:8px;margin-top:6px;align-items:center">
          <div class="small-muted">Day streak:</div>
          <div id="streak">0</div>
          <button class="btn ghost" id="claimDaily">Claim +5</button>
        </div>
      </div>

    </div>

    <div class="card right">
      <div class="board-wrap">
        <div>
          <div class="board" id="board"></div>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <div class="small">Turn:</div>
            <div id="turnIndicator">white</div>
            <button class="btn ghost" id="undoBtn">Undo</button>
            <button class="btn" id="restartBtn">Restart</button>
          </div>
        </div>

        <div style="width:320px">
          <div class="controls card" style="padding:12px">
            <div class="small">Match</div>
            <div class="small-muted" id="matchMode">Local</div>

            <div style="margin-top:8px" class="small">Moves</div>
            <div class="moves" id="movesList">-- no moves yet --</div>

            <div style="margin-top:10px" class="small">Last result</div>
            <div id="resultBox" class="small-muted">None</div>

            <div style="margin-top:8px;display:flex;gap:8px">
              <button class="btn" id="resignBtn">Resign</button>
              <button class="btn ghost" id="offerDraw">Offer Draw</button>
            </div>
          </div>

          <footer>
            <div class="small-muted">Tip: Open same page in another tab and click "Play with Friend" to simulate a cross-tab match.</div>
          </footer>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.5/chess.min.js"></script>
  <script>
    // Simple single-file chess app with stake system, localStorage account, and multi-tab friend simulation.

    // ---------- Utilities ----------
    function uid(){return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16))}
    function now(){return new Date().toLocaleTimeString()}
    function log(msg){const el=document.getElementById('matchLog');el.innerHTML += `\n[${now()}] ${msg}`; el.scrollTop = el.scrollHeight}

    // ---------- Account & Persistence ----------
    const KEY = 'chess_demo_account_v1'
    let account = JSON.parse(localStorage.getItem(KEY) || 'null') || {id:null,name:'Player-' + Math.random().toString(36).slice(2,6),coins:45,streak:0,lastClaim:null}
    if(!account.id) account.id = uid()
    function saveAccount(){localStorage.setItem(KEY, JSON.stringify(account)); document.getElementById('playerId').innerText = 'Player ID: ' + account.id; document.getElementById('coins').innerText = account.coins}
    saveAccount()

    document.getElementById('saveBtn').addEventListener('click', ()=>{saveAccount(); alert('Saved!')})
    document.getElementById('importBtn').addEventListener('click', ()=>{ const raw = prompt('Paste account JSON to restore'); try{ account = JSON.parse(raw); saveAccount(); alert('Restored'); }catch(e){alert('Invalid JSON')}})

    // ---------- Stakes & Modes ----------
    let selectedStake = 5
    document.querySelectorAll('.stake').forEach(el=>{ el.addEventListener('click', ()=>{ document.querySelectorAll('.stake').forEach(s=>s.classList.remove('active')); el.classList.add('active'); selectedStake = Number(el.dataset.value); log('Stake set to ' + selectedStake) }) })
    // default select first
    document.querySelector('.stake').classList.add('active')

    // modes
    const statusEl = document.getElementById('status')
    let currentMode = 'local' // 'friend' | 'random' | 'local'
    document.getElementById('modeFriend').addEventListener('click', ()=> startFriendMatch())
    document.getElementById('modeRandom').addEventListener('click', ()=> startRandomMatch())
    document.getElementById('modeOffline').addEventListener('click', ()=> startOfflineMatch())

    // ---------- Chess board + moves using chess.js ----------
    const CHESS = new Chess()
    const boardEl = document.getElementById('board')
    const movesEl = document.getElementById('movesList')
    const turnIndicator = document.getElementById('turnIndicator')
    let selectedSquare = null

    function renderBoard(){
      boardEl.innerHTML = ''
      const letters = ['a','b','c','d','e','f','g','h']
      for(let r=8;r>=1;r--){
        for(let f=0;f<8;f++){
          const sq = letters[f] + r
          const div = document.createElement('div')
          div.className = 'square ' + (((r+f)%2)?'sq-dark':'sq-light')
          div.dataset.sq = sq
          const piece = CHESS.get(sq)
          if(piece){ div.innerHTML = `<div class="piece">${pieceSymbol(piece)}</div>` }
          div.addEventListener('click', ()=> onSquareClick(sq, div))
          boardEl.appendChild(div)
        }
      }
      turnIndicator.innerText = CHESS.turn() === 'w' ? 'white' : 'black'
    }

    function pieceSymbol(p){
      const map = { p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚' }
      return p.color === 'w' ? map[p.type].toUpperCase() : map[p.type]
    }

    function onSquareClick(sq, el){
      // highlight
      document.querySelectorAll('.square').forEach(s=>s.classList.remove('highlight'))
      el.classList.add('highlight')
      if(selectedSquare === null){ selectedSquare = sq; return }
      // try move
      const move = CHESS.move({ from:selectedSquare, to:sq, promotion:'q' })
      selectedSquare = null
      if(move){ updateMoves(); renderBoard(); checkGameOver(); notifyMove(move) } else { log('Invalid move') }
    }

    function updateMoves(){
      const history = CHESS.history({ verbose:true })
      if(history.length === 0) movesEl.innerText = '-- no moves yet --'
      else movesEl.innerText = history.map((m,i)=> (i%2? `${m.san}`: `${Math.floor(i/2)+1}. ${m.san}`)).join(' ')
    }

    function notifyMove(move){ log(`Move: ${move.san}`) }

    function checkGameOver(){
      if(CHESS.game_over()){
        let res = 'Draw'
        if(CHESS.in_checkmate()){
          res = (CHESS.turn() === 'b') ? 'White wins (checkmate)' : 'Black wins (checkmate)'
        } else if(CHESS.in_stalemate()){ res = 'Stalemate' }
        document.getElementById('resultBox').innerText = res
        log('Game over: ' + res)
        finalizeMatch(res)
      }
    }

    // Undo & restart
    document.getElementById('undoBtn').addEventListener('click', ()=>{ const mv = CHESS.undo(); if(mv){ updateMoves(); renderBoard(); log('Undo: ' + mv.san) } })
    document.getElementById('restartBtn').addEventListener('click', ()=>{ CHESS.reset(); updateMoves(); renderBoard(); document.getElementById('resultBox').innerText='None'; log('Board reset') })

    // Resign
    document.getElementById('resignBtn').addEventListener('click', ()=>{ const winner = CHESS.turn() === 'w' ? 'Black (resign)' : 'White (resign)'; log('Resigned — ' + winner); finalizeMatch(winner); })

    // ---------- Match finalization & coin handling ----------
    function finalizeMatch(resultText){
      // Evaluate winner for stake distribution (very simple parsing)
      let change = 0
      if(resultText.toLowerCase().includes('white wins') || resultText.toLowerCase().includes('black') && resultText.toLowerCase().includes('wins')){
        // check who won — if account plays white by default
        // For simplicity assume local player is always white in online matches initiated from this tab
        const youAreWhite = (currentMode !== 'friend') ? true : (localRole === 'white')
        if(resultText.toLowerCase().includes('white')){
          change = youAreWhite ? selectedStake : -selectedStake
        } else if(resultText.toLowerCase().includes('black')){
          change = youAreWhite ? -selectedStake : selectedStake
        }
      } else if(resultText.toLowerCase().includes('draw') || resultText.toLowerCase().includes('stalemate')){
        change = 0
      } else if(resultText.toLowerCase().includes('resign')){
        // resign text contains who won
        change = resultText.toLowerCase().includes('white') ? selectedStake : -selectedStake
      }

      if(currentMode === 'local' || currentMode === 'offline' || currentMode === 'random' || currentMode === 'friend'){
        account.coins += change
        saveAccount()
        log('Coins ' + (change>=0? 'won +' : 'lost ') + change + '. New balance: ' + account.coins)
      }
    }

    // ---------- Offline (vs computer) ----------
    document.getElementById('modeOffline').addEventListener('click', startOfflineMatch)
    function startOfflineMatch(){
      currentMode = 'offline'
      document.getElementById('matchMode').innerText = 'Offline (vs Computer)'
      CHESS.reset(); renderBoard(); updateMoves(); document.getElementById('resultBox').innerText='None'
      log('Started offline match vs computer. Stake: ' + selectedStake)
      statusEl.innerText = 'Status: Playing vs Computer'
      // we'll make computer play immediate random legal move when it's black's turn
      computerPlayLoop()
    }

    function computerPlayLoop(){
      // simple loop checking if computer to move
      const loop = setInterval(()=>{
        if(CHESS.game_over()){ clearInterval(loop); checkGameOver(); return }
        if(CHESS.turn() === 'b'){ // computer plays black
          const moves = CHESS.moves()
          const mv = moves[Math.floor(Math.random()*moves.length)]
          CHESS.move(mv)
          updateMoves(); renderBoard(); log('Computer plays ' + mv); checkGameOver()
        }
      }, 700)
    }

    // ---------- Random Match (simulated) ----------
    function startRandomMatch(){
      currentMode = 'random'
      document.getElementById('matchMode').innerText = 'Random Match (simulated)'
      statusEl.innerText = 'Status: Searching random players...'
      log('Searching random players...')
      // simulate matchmaking delay
      setTimeout(()=>{
        CHESS.reset(); renderBoard(); updateMoves(); document.getElementById('resultBox').innerText='None'
        statusEl.innerText = 'Status: Paired with random opponent (simulated)'
        log('Paired with random opponent — match start')
        // simulate opponent moves as a second player that occasionally plays
        simulatedOpponentLoop()
      }, 1400 + Math.random()*2000)
    }

    function simulatedOpponentLoop(){
      // simulate opponent that plays every 1-2s when it's black's turn
      const loop = setInterval(()=>{
        if(CHESS.game_over()){ clearInterval(loop); checkGameOver(); return }
        if(CHESS.turn() === 'b'){
          const moves = CHESS.moves()
          const mv = moves[Math.floor(Math.random()*moves.length)]
          CHESS.move(mv)
          updateMoves(); renderBoard(); log('Opponent plays ' + mv)
          checkGameOver()
        }
      }, 800 + Math.random()*1200)
    }

    // ---------- Friend Match (multi-tab using localStorage) ----------
    // We'll use a small protocol: set localStorage['chess_match_request'] with {id,from,role} to invite
    let localRole = null
    function startFriendMatch(){
      currentMode = 'friend'
      document.getElementById('matchMode').innerText = 'Play with Friend (multi-tab)'
      statusEl.innerText = 'Status: Waiting for friend... (open another tab and click Play with Friend)'
      log('Friend match: waiting for partner — broadcasting invite')
      // broadcast invite
      const invite = {id: uid(), from: account.id, time: Date.now()}
      localStorage.setItem('chess_match_invite', JSON.stringify(invite))

      // wait for accept via storage event (other tab will write chess_match_accept)
    }

    window.addEventListener('storage', (e)=>{
      try{
        if(e.key === 'chess_match_invite'){ const inv = JSON.parse(e.newValue); if(inv.from !== account.id){ // accept invite automatically
            log('Found invite from ' + inv.from + '. Accepting...'); const acc = {inviteId:inv.id,acceptor:account.id,role:'black',time:Date.now()}; localStorage.setItem('chess_match_accept', JSON.stringify(acc)) }
        }
        if(e.key === 'chess_match_accept'){ const acc = JSON.parse(e.newValue); if(acc.acceptor !== account.id){ // we are the acceptor side in other tab
            // if we wrote accept, start match
          }
          // If we are the one who initiated invite, and acceptor is different -> start match
          if(currentMode === 'friend'){
            log('Match accepted by ' + acc.acceptor)
            // assign roles: inviter is white, acceptor is black
            localRole = (acc.acceptor === account.id) ? 'black' : 'white'
            statusEl.innerText = 'Status: Friend matched — role: ' + localRole
            CHESS.reset(); renderBoard(); updateMoves(); document.getElementById('resultBox').innerText='None'
            log('Friend match started — you are ' + localRole)
            // start a simple loop: if you are black, opponent moves as other tab
            if(localRole === 'white'){ // wait for opponent moves via storage
              // both tabs will use storage key 'chess_move_<matchId>' to send moves
            }
          }
        }
        if(e.key && e.key.startsWith('chess_move_')){
          const m = JSON.parse(e.newValue)
          // ignore if move originated here
          if(m.from === account.id) return
          if(m.san){ CHESS.move(m.san); updateMoves(); renderBoard(); log('Friend played: ' + m.san); checkGameOver() }
        }
      }catch(err){console.error(err)}
    })

    // When in friend mode, after making moves broadcast them
    function broadcastMoveSAN(san){
      // find current match id (use last invite)
      const invite = JSON.parse(localStorage.getItem('chess_match_invite') || 'null')
      const matchId = invite ? invite.id : 'local_friend'
      const key = 'chess_move_' + matchId
      localStorage.setItem(key, JSON.stringify({from:account.id, san:san, time:Date.now()}))
    }

    // Patch notifyMove to broadcast when friend match
    const originalNotify = notifyMove
    notifyMove = function(move){ originalNotify(move); if(currentMode === 'friend'){ broadcastMoveSAN(move.san) } }

    // ---------- Daily bonus ----------
    const claimBtn = document.getElementById('claimDaily')
    function loadDaily(){ document.getElementById('streak').innerText = account.streak; document.getElementById('coins').innerText = account.coins }
    claimBtn.addEventListener('click', ()=>{
      const today = new Date().toDateString()
      if(account.lastClaim === today){ alert('Already claimed today') ; return }
      // if previous claim was yesterday increment streak else reset
      const yesterday = new Date(Date.now() - 86400000).toDateString()
      if(account.lastClaim === yesterday) account.streak = Math.min(account.streak+1,3)
      else account.streak = 1
      account.lastClaim = today
      const reward = 5
      account.coins += reward
      saveAccount(); loadDaily(); log('Claimed daily +'+reward)
    })

    // ---------- Init ----------
    renderBoard(); updateMoves(); loadDaily(); document.getElementById('playerId').innerText = 'Player ID: ' + account.id

    // When user makes a move in friend match, broadcast
    // We need to override CHESS.move usage to capture SAN — we do in notifyMove wrapper

    // Show initial log
    log('Welcome ' + account.name + ' — coins: ' + account.coins)

    // When page closed, do a friendly log
    window.addEventListener('beforeunload', ()=>{ log('Leaving tab') })

  </script>
</body>
</html>
