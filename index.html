<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chess — Online & Offline (Stakes & Coins) — Improved</title>
  <style>
    :root{ --bg:#0f1724; --card:#0b1220; --accent:#06b6d4; --muted:#9aa6b2; --win:#10b981; --lose:#ef4444 }
    *{box-sizing:border-box;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Arial}
    body{margin:0;background:linear-gradient(180deg,#071026 0%, #071422 100%);color:#e6eef6;min-height:100vh;padding:18px}
    .app{display:grid;grid-template-columns:360px 1fr;gap:18px;align-items:start}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,0.7);}
    header h1{margin:0;font-size:20px}
    .left .section{margin-bottom:12px}
    .account-row{display:flex;justify-content:space-between;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    .coins{display:flex;gap:10px;align-items:center}
    .coin-badge{background:linear-gradient(90deg,#ffd166,#f97316);color:#051025;padding:6px 10px;border-radius:999px;font-weight:700}
    .btn{background:var(--accent);color:#022; padding:8px 10px;border-radius:8px;font-weight:600;border:none;cursor:pointer}
    .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}
    .stakes{display:flex;gap:8px;margin-top:10px}
    .stake{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);cursor:pointer}
    .stake.active{background:rgba(6,182,212,0.12);border-color:rgba(6,182,212,0.3)}
    .modes{display:flex;gap:8px;margin-top:8px}
    .status{margin-top:8px;font-size:13px}
    .match-log{height:140px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:10px;font-size:13px;white-space:pre-wrap}

    /* board */
    .board-wrap{display:flex;gap:18px;align-items:flex-start}
    .board{width:480px;height:480px;background:#dcdcdc;border-radius:8px;display:grid;grid-template-columns:repeat(8,1fr);grid-template-rows:repeat(8,1fr);overflow:hidden}
    .square{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:28px;cursor:pointer;user-select:none}
    .sq-dark{background:#6b4f36}
    .sq-light{background:#f3ecd6}
    .highlight{outline:4px solid rgba(6,182,212,0.24);}
    .piece{pointer-events:none}

    /* right side */
    .controls{display:flex;flex-direction:column;gap:12px}
    .moves{height:220px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
    .small-muted{color:var(--muted);font-size:13px}
    footer{margin-top:12px;color:var(--muted);font-size:13px}

    @media (max-width:940px){.app{grid-template-columns:1fr;}.board{width:100%;height:360px}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card left">
      <header>
        <h1>Online — Choose stake & mode</h1>
        <div class="small">Play Random / Play with Friend / Local & Offline</div>
      </header>

      <div class="section">
        <div class="account-row">
          <div>
            <div class="small">Account</div>
            <div id="playerName">Player-a423</div>
            <div class="small-muted" id="playerId">Player ID: generating...</div>
          </div>
          <div class="coins">
            <div class="coin-badge" id="coins">0</div>
          </div>
        </div>

        <div style="margin-top:10px;display:flex;gap:8px;">
          <button class="btn" id="saveBtn">Save</button>
          <button class="btn ghost" id="importBtn">Import/Restore</button>
        </div>
      </div>

      <div class="section">
        <div class="small">Select Stake</div>
        <div class="stakes" id="stakes">
          <div class="stake" data-value="5">5</div>
          <div class="stake" data-value="10">10</div>
          <div class="stake" data-value="20">20</div>
        </div>

        <div class="small" style="margin-top:8px">Mode</div>
        <div class="modes">
          <button class="btn ghost" id="modeFriend">Play with Friend</button>
          <button class="btn" id="modeRandom">Play Random</button>
          <button class="btn" id="modeOffline">Offline (vs Computer)</button>
        </div>

        <div class="status small" id="status">Status: Idle</div>
        <div class="match-log" id="matchLog">[-- match log --]</div>
      </div>

      <div class="section">
        <div class="small">Help & Notes</div>
        <div class="small-muted" style="margin-top:6px">
          Open this page in another tab to simulate online players (local multi-tab). For real cross-device matches you need a server. Chess rules are enforced using chess.js. Coins are stored in localStorage and used for stakes/computer wins.
        </div>
      </div>

      <div class="section">
        <div class="small">Daily Bonus</div>
        <div style="display:flex;gap:8px;margin-top:6px;align-items:center">
          <div class="small-muted">Day streak:</div>
          <div id="streak">0</div>
          <button class="btn ghost" id="claimDaily">Claim +5</button>
        </div>
      </div>

    </div>

    <div class="card right">
      <div class="board-wrap">
        <div>
          <div class="board" id="board"></div>
          <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
            <div class="small">Turn:</div>
            <div id="turnIndicator">white</div>
            <button class="btn ghost" id="undoBtn">Undo</button>
            <button class="btn" id="restartBtn">Restart</button>
          </div>
        </div>

        <div style="width:320px">
          <div class="controls card" style="padding:12px">
            <div class="small">Match</div>
            <div class="small-muted" id="matchMode">Local</div>

            <div style="margin-top:8px" class="small">Moves</div>
            <div class="moves" id="movesList">-- no moves yet --</div>

            <div style="margin-top:10px" class="small">Last result</div>
            <div id="resultBox" class="small-muted">None</div>

            <div style="margin-top:8px;display:flex;gap:8px">
              <button class="btn" id="resignBtn">Resign</button>
              <button class="btn ghost" id="offerDraw">Offer Draw</button>
            </div>
          </div>

          <footer>
            <div class="small-muted">Tip: Open same page in another tab and click "Play with Friend" to simulate a cross-tab match.</div>
          </footer>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.13.5/chess.min.js"></script>
  <script>
    // Improved single-file chess app — fixes:
    // - friend-match protocol (matchId + accept) so both tabs sync
    // - notify/broadcast ordering fixed
    // - safer storage parsing, try/catch for incoming SAN moves
    // - clearer button feedback and active states

    // ---------- Utilities ----------
    function uid(){return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g,c=>(c^crypto.getRandomValues(new Uint8Array(1))[0]&15>>c/4).toString(16))}
    function now(){return new Date().toLocaleTimeString()}
    function log(msg){const el=document.getElementById('matchLog'); el.innerText += `\n[${now()}] ${msg}`; el.scrollTop = el.scrollHeight}

    // ---------- Account & Persistence ----------
    const KEY = 'chess_demo_account_v2'
    let account = JSON.parse(localStorage.getItem(KEY) || 'null') || {id:null,name:'Player-' + Math.random().toString(36).slice(2,6),coins:45,streak:0,lastClaim:null}
    if(!account.id) account.id = uid()
    function saveAccount(){localStorage.setItem(KEY, JSON.stringify(account)); document.getElementById('playerId').innerText = 'Player ID: ' + account.id; document.getElementById('coins').innerText = account.coins}
    saveAccount()

    document.getElementById('saveBtn').addEventListener('click', ()=>{saveAccount(); alert('Saved!')})
    document.getElementById('importBtn').addEventListener('click', ()=>{ const raw = prompt('Paste account JSON to restore'); try{ account = JSON.parse(raw); saveAccount(); alert('Restored'); }catch(e){alert('Invalid JSON')}})

    // ---------- Stakes & Modes ----------
    let selectedStake = 5
    document.querySelectorAll('.stake').forEach(el=>{ el.addEventListener('click', ()=>{ document.querySelectorAll('.stake').forEach(s=>s.classList.remove('active')); el.classList.add('active'); selectedStake = Number(el.dataset.value); log('Stake set to ' + selectedStake) }) })
    document.querySelector('.stake').classList.add('active')

    // modes
    const statusEl = document.getElementById('status')
    let currentMode = 'local' // 'friend' | 'random' | 'local' | 'offline'
    let currentMatchId = null
    let localRole = null

    const btnFriend = document.getElementById('modeFriend')
    const btnRandom = document.getElementById('modeRandom')
    const btnOffline = document.getElementById('modeOffline')

    btnFriend.addEventListener('click', ()=> startFriendMatch())
    btnRandom.addEventListener('click', ()=> startRandomMatch())
    btnOffline.addEventListener('click', ()=> startOfflineMatch())

    function setModeButtonsActive(id){ [btnFriend, btnRandom, btnOffline].forEach(b=>b.classList.remove('active')); document.getElementById(id).classList.add('active') }

    // ---------- Chess board + moves using chess.js ----------
    const CHESS = new Chess()
    const boardEl = document.getElementById('board')
    const movesEl = document.getElementById('movesList')
    const turnIndicator = document.getElementById('turnIndicator')
    let selectedSquare = null

    function renderBoard(){
      boardEl.innerHTML = ''
      const letters = ['a','b','c','d','e','f','g','h']
      for(let r=8;r>=1;r--){
        for(let f=0;f<8;f++){
          const sq = letters[f] + r
          const div = document.createElement('div')
          div.className = 'square ' + (((r+f)%2)?'sq-dark':'sq-light')
          div.dataset.sq = sq
          const piece = CHESS.get(sq)
          if(piece){ div.innerHTML = `<div class="piece">${pieceSymbol(piece)}</div>` }
          div.addEventListener('click', ()=> onSquareClick(sq, div))
          boardEl.appendChild(div)
        }
      }
      turnIndicator.innerText = CHESS.turn() === 'w' ? 'white' : 'black'
    }

    function pieceSymbol(p){
      const map = { p:'♟', r:'♜', n:'♞', b:'♝', q:'♛', k:'♚' }
      return p.color === 'w' ? map[p.type].toUpperCase() : map[p.type]
    }

    function onSquareClick(sq, el){
      // highlight
      document.querySelectorAll('.square').forEach(s=>s.classList.remove('highlight'))
      el.classList.add('highlight')
      if(selectedSquare === null){ selectedSquare = sq; return }
      // try move
      const move = CHESS.move({ from:selectedSquare, to:sq, promotion:'q' })
      selectedSquare = null
      if(move){ updateMoves(); renderBoard(); checkGameOver(); notifyAndBroadcast(move) } else { log('Invalid move') }
    }

    function updateMoves(){
      const history = CHESS.history({ verbose:true })
      if(history.length === 0) movesEl.innerText = '-- no moves yet --'
      else movesEl.innerText = history.map((m,i)=> (i%2? `${m.san}`: `${Math.floor(i/2)+1}. ${m.san}`)).join(' ')
    }

    // Combined notifier + broadcast (used after a successful local move)
    function notifyAndBroadcast(move){
      log(`Move: ${move.san}`)
      if(currentMode === 'friend' && currentMatchId){ broadcastMoveSAN(move.san) }
    }

    function checkGameOver(){
      if(CHESS.game_over()){
        let res = 'Draw'
        if(CHESS.in_checkmate()){
          // if it's checkmate, the player who *didn't* move last is the winner
          const winner = CHESS.turn() === 'w' ? 'Black' : 'White'
          res = `${winner} wins (checkmate)`
        } else if(CHESS.in_stalemate()){ res = 'Stalemate' }
        document.getElementById('resultBox').innerText = res
        log('Game over: ' + res)
        finalizeMatch(res)
      }
    }

    // Undo & restart
    document.getElementById('undoBtn').addEventListener('click', ()=>{ const mv = CHESS.undo(); if(mv){ updateMoves(); renderBoard(); log('Undo: ' + (mv.san||JSON.stringify(mv))) } })
    document.getElementById('restartBtn').addEventListener('click', ()=>{ CHESS.reset(); updateMoves(); renderBoard(); document.getElementById('resultBox').innerText='None'; log('Board reset') })

    // Resign
    document.getElementById('resignBtn').addEventListener('click', ()=>{ const winner = CHESS.turn() === 'w' ? 'Black (resign)' : 'White (resign)'; log('Resigned — ' + winner); finalizeMatch(winner); })

    // ---------- Match finalization & coin handling ----------
    function finalizeMatch(resultText){
      // safer parsing and parentheses fixed
      let change = 0
      const low = resultText.toLowerCase()
      if(low.includes('wins')){
        const whiteWon = low.includes('white')
        const youAreWhite = (currentMode !== 'friend') ? true : (localRole === 'white')
        if(whiteWon) change = youAreWhite ? selectedStake : -selectedStake
        else change = youAreWhite ? -selectedStake : selectedStake
      } else if(low.includes('draw') || low.includes('stalemate')){
        change = 0
      } else if(low.includes('resign')){
        // 'Black (resign)' means black won — parse accordingly
        change = low.includes('white') ? selectedStake : -selectedStake
      }

      if(currentMode === 'local' || currentMode === 'offline' || currentMode === 'random' || currentMode === 'friend'){
        account.coins += change
        saveAccount()
        log('Coins ' + (change>=0? 'won +' : 'lost ') + change + '. New balance: ' + account.coins)
      }
    }

    // ---------- Offline (vs computer) ----------
    function startOfflineMatch(){
      currentMode = 'offline'
      setModeButtonsActive('modeOffline')
      document.getElementById('matchMode').innerText = 'Offline (vs Computer)'
      CHESS.reset(); renderBoard(); updateMoves(); document.getElementById('resultBox').innerText='None'
      log('Started offline match vs computer. Stake: ' + selectedStake)
      statusEl.innerText = 'Status: Playing vs Computer'
      computerPlayLoop()
    }

    function computerPlayLoop(){
      const loop = setInterval(()=>{
        if(CHESS.game_over()){ clearInterval(loop); checkGameOver(); return }
        if(CHESS.turn() === 'b'){
          const moves = CHESS.moves()
          const mv = moves[Math.floor(Math.random()*moves.length)]
          CHESS.move(mv)
          updateMoves(); renderBoard(); log('Computer plays ' + mv); checkGameOver()
        }
      }, 700)
    }

    // ---------- Random Match (simulated) ----------
    function startRandomMatch(){
      currentMode = 'random'
      setModeButtonsActive('modeRandom')
      document.getElementById('matchMode').innerText = 'Random Match (simulated)'
      statusEl.innerText = 'Status: Searching random players...'
      log('Searching random players...')
      setTimeout(()=>{
        CHESS.reset(); renderBoard(); updateMoves(); document.getElementById('resultBox').innerText='None'
        statusEl.innerText = 'Status: Paired with random opponent (simulated)'
        log('Paired with random opponent — match start')
        simulatedOpponentLoop()
      }, 1000 + Math.random()*1500)
    }

    function simulatedOpponentLoop(){
      const loop = setInterval(()=>{
        if(CHESS.game_over()){ clearInterval(loop); checkGameOver(); return }
        if(CHESS.turn() === 'b'){
          const moves = CHESS.moves()
          const mv = moves[Math.floor(Math.random()*moves.length)]
          CHESS.move(mv)
          updateMoves(); renderBoard(); log('Opponent plays ' + mv)
          checkGameOver()
        }
      }, 800 + Math.random()*1200)
    }

    // ---------- Friend Match (multi-tab using localStorage) ----------
    // Protocol:
    // - inviter writes 'chess_match_invite' = {matchId, from}
    // - acceptor sees invite and writes 'chess_match_accept' = {matchId, from, acceptor}
    // - both tabs then set currentMatchId = matchId and roles: inviter=white, acceptor=black

    function startFriendMatch(){
      currentMode = 'friend'
      setModeButtonsActive('modeFriend')
      document.getElementById('matchMode').innerText = 'Play with Friend (multi-tab)'
      statusEl.innerText = 'Status: Waiting for friend... (open another tab and click Play with Friend)'
      log('Friend match: broadcasting invite')
      const matchId = uid()
      const invite = {matchId, from: account.id, time: Date.now()}
      localStorage.setItem('chess_match_invite', JSON.stringify(invite))
      // set this tab as inviter and wait for accept
      currentMatchId = matchId
      localRole = 'white'
    }

    window.addEventListener('storage', (e)=>{
      try{
        if(!e.key) return
        // Invite discovered
        if(e.key === 'chess_match_invite'){
          const inv = JSON.parse(e.newValue || '{}')
          if(inv.from && inv.from !== account.id){
            log('Found invite from ' + inv.from + ' — accepting')
            const acc = {matchId: inv.matchId, from: inv.from, acceptor: account.id, time: Date.now()}
            localStorage.setItem('chess_match_accept', JSON.stringify(acc))
            // set acceptor state
            currentMatchId = inv.matchId
            localRole = 'black'
            currentMode = 'friend'
            document.getElementById('matchMode').innerText = 'Play with Friend (multi-tab)'
            statusEl.innerText = 'Status: Accepted invite — connected as black'
            CHESS.reset(); renderBoard(); updateMoves(); document.getElementById('resultBox').innerText='None'
            log('Friend match started — you are black')
          }
        }

        // Accept discovered
        if(e.key === 'chess_match_accept'){
          const acc = JSON.parse(e.newValue || '{}')
          if(acc.from && acc.from !== account.id){
            // inviter sees accept — start match
            if(currentMode === 'friend' && currentMatchId === acc.matchId){
              localRole = 'white'
              statusEl.innerText = 'Status: Friend matched — role: ' + localRole
              CHESS.reset(); renderBoard(); updateMoves(); document.getElementById('resultBox').innerText='None'
              log('Match accepted by ' + acc.acceptor + ' — you are white')
            }
          }
        }

        // Moves for this match
        if(e.key && e.key.startsWith('chess_move_')){
          const payload = JSON.parse(e.newValue || '{}')
          if(!payload || !payload.matchId) return
          if(payload.matchId !== currentMatchId) return // ignore other matches
          if(payload.from === account.id) return // ignore our own writes
          // apply opponent move safely
          try{
            const applied = CHESS.move(payload.san)
            if(applied){ updateMoves(); renderBoard(); log('Friend played: ' + payload.san); checkGameOver() }
          }catch(err){ console.error('Failed to apply friend move:', err) }
        }
      }catch(err){console.error(err)}
    })

    function broadcastMoveSAN(san){
      if(!currentMatchId) return
      const key = 'chess_move_' + currentMatchId
      const payload = {matchId: currentMatchId, from: account.id, san: san, time: Date.now()}
      localStorage.setItem(key, JSON.stringify(payload))
    }

    // ---------- Daily bonus ----------
    const claimBtn = document.getElementById('claimDaily')
    function loadDaily(){ document.getElementById('streak').innerText = account.streak; document.getElementById('coins').innerText = account.coins }
    claimBtn.addEventListener('click', ()=>{
      const today = new Date().toDateString()
      if(account.lastClaim === today){ alert('Already claimed today') ; return }
      const yesterday = new Date(Date.now() - 86400000).toDateString()
      if(account.lastClaim === yesterday) account.streak = Math.min(account.streak+1,3)
      else account.streak = 1
      account.lastClaim = today
      const reward = 5
      account.coins += reward
      saveAccount(); loadDaily(); log('Claimed daily +'+reward)
    })

    // ---------- Init ----------
    renderBoard(); updateMoves(); loadDaily(); document.getElementById('playerId').innerText = 'Player ID: ' + account.id
    log('Welcome ' + account.name + ' — coins: ' + account.coins)

    // small helper: if localStorage keys exist from previous runs, clear old chess_move_* entries to avoid confusion
    // NOTE: keep this commented unless needed for debugging
    // Object.keys(localStorage).filter(k=>k.startsWith('chess_move_')).forEach(k=>localStorage.removeItem(k))

    window.addEventListener('beforeunload', ()=>{ log('Leaving tab') })
  </script>
</body>
</html>
